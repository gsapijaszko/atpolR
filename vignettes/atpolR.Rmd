---
title: "Introduction to atpolR"
output: 
 bookdown::html_document2:
   base_format: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to atpolR}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: ../inst/REFERENCES.bib
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(atpolR)
```

# Introduction
ATPOL grid was developed in late '60s in Institute of Botany at Jagiellonian University in Kraków. The backgrounds and methodology is described in [@zajacAtlasDistributionVascular1978; @zajacZalozeniaMetodyczneAtlasu1978]; for the first time the grid was used in "Distribution atlas of vascular plants in Poland". The extensive mathematical research and GIS implementation was done by Łukasz Komsta and Marek Verey [@komstaRewizjaMatematycznaSiatki2016; @vereyTeoretycznaAnalizaPraktyczne2017]. Algorithms provided by Komsta on [OpenATPOL](https://atpol.sourceforge.io/) are basis for implementation in `atpolR` package.

# Basic usage

## Prepare sample data based on published ATPOL data

In our example we will take a published distribution map of _Erigeron acris_ L. subsp. _acris_ published in  [@zajacAtlasRozmieszczeniaRoslin2019]. The image was scanned with resolution 150 dpi and georefenced using QGIS.

```{r eriacr, fig.width = 7, fig.align='center', fig.cap = "_Erigeron acris_ L. subsp. _acris_ distribution taken from [@zajacAtlasRozmieszczeniaRoslin2019]"}
par(mar = c(0, 0, 0, 0))
tif <- system.file("extdata/eriacr.tif", package = "atpolR")
r <- terra::rast(tif)
terra::plotRGB(r)
```

There is hundreds of records. To get all of them we will use `check_atpol_square()` function, which takes as the arguments the POINT coordinates and a raster, and checks if the value of raster cell corresponding to POINT equals zero. As the points are drawn in centers of ATPOL 10 km grid, we will check the values of atpol10k() centroids with an buffer, default with radius of 1200 m. Depending of the quality of scan and precission of georefencing, it might be useful to adjust a buffer a bit.

Our raster usually consist of 3 layers, one for each R, G, B component. The difference between them are visible on Fig. \@ref(fig:rgbraster).

```{r rgbraster, echo = FALSE, message=FALSE, warning=FALSE, results='hide', fig.width = 7, fig.align='center', fig.cap="R, G and B layers of a raster"}
par(mar = c(0, 0, 0, 0))
par(mfrow = c(1, 3))
for (d in c(1:3)) {
  terra::plot(r[[d]], legend = TRUE)
}
par(mfrow = c(1, 1))
```

Looking on scan shown on Fig. \@ref(fig:eriacr) we can see a lot of green and blue components. For further analysis we will take the first layer only

```{r rraster, echo = TRUE, message=FALSE, warning=FALSE, results='hide', fig.width = 7, fig.asp = 0.7, fig.align='center'}
par(mar = c(0, 0, 0, 0))
terra::plot(r[[1]], axes = FALSE)
```

Let's classify the layer, just assigning two values, 0 and 1

```{r echo = TRUE, message=FALSE, warning=FALSE, results='hide', fig.width = 7, fig.height = 7, fig.align='center'}
m <- c(0,120, 0,
       120,255, 1)
rclmat <- matrix(m, ncol=3, byrow=TRUE)

rc <- terra::classify(r[[1]], rclmat, include.lowest = TRUE)
terra::plot(rc, axes = FALSE, col = c("black", "white"), legend = FALSE)
```

Having the raster prepared we can apply the `check_atpol_square()` function for all 10k grids:

```{r eriacr-reverse}
eriacr <- atpol10k()|>
  dplyr::mutate(a = mapply(function(x) check_atpol_square(x, rc), centroid)) |>
  dplyr::filter(a == "YES")
```

There is 709 observations (points) in data set.

Let's check BE square:

```{r BE, fig.width =7, fig.height = 7, fig.align='center'}
BE <- atpolR::atpol100k() |>
  subset(Name == "BE") |>
  sf::st_bbox()
par(pty = "s")
plot(NA, type = "n", xlim = c(BE[1], BE[3]), ylim = c(BE[2], BE[4]), axes = FALSE, xlab = "", ylab = "")
terra::plot(rc, legend = FALSE, add = TRUE)
atpolR::atpol100k() |>
  subset(Name == "BE") |>
  sf::st_cast("LINESTRING") |>
  terra::plot(add = TRUE, col = "blue", lwd = 1.2)

eriacr |>
  subset(substr(Name, 1, 2) == "BE")
eriacr$buffer <- sf::st_buffer(eriacr$centroid, 1500)
terra::plot(eriacr$buffer, col = "blue", add = TRUE)
```

## Extend data

Lets assume, we want to extend the data set with own observations from . We can simply filter out the grid created by `atpol10k()` function using either Name or giving the coordinates within `latlon_to_grid()`:

```{r myData, fig.height = 7}
myData <- atpol10k() |>
  dplyr::filter(Name %in% c("BE68", 
                            latlon_to_grid(51.13619444, 16.95069444, 4))) |>
  dplyr::mutate(a = "myData")

BE <- atpolR::atpol100k() |>
  subset(Name == "BE") |>
  sf::st_bbox()
par(pty = "s")
plot(NA, type = "n", xlim = c(BE[1], BE[3]), ylim = c(BE[2], BE[4]), axes = FALSE, xlab = "", ylab = "")
terra::plot(rc, add = TRUE)
atpolR::atpol100k() |>
  subset(Name == "BE") |>
  sf::st_cast("LINESTRING") |>
  terra::plot(add = TRUE, col = "blue", lwd = 1.2)

be <- eriacr |>
  subset(substr(Name, 1, 2) == "BE")
be$buffer <- sf::st_buffer(be$centroid, 1500)
terra::plot(be$buffer, col = "blue", add = TRUE)

pl <- myData |>
  dplyr::mutate(buffer = sf::st_buffer(.data$centroid, 1500))
terra::plot(pl$buffer, col = "red", add = TRUE)
```  

## Plot it 

# Functions description

Two basic functions `latlon_to_grid()` and `grid_to_latlon()` allows to quickly convert geographical coordinates (given in WGS 84 latitude and longitude degrees) to ATPOL grid and from grid to coordinates respectively.

```{r}
latlon_to_grid(51.01234, 17.23456, 4)
latlon_to_grid(51.01234, 17.23456, 6)
```
The firs two arguments `latlon_to_grid()` function are latitude and longitude respectively. The third argument is the length of returned grid; it might be even number between 2 and 12.

```{r}
grid_to_latlon("CE50")
```
By default `grid_to_latlon()` returns the center of grid square. If you wish to get it's corners, you can pass another 2 arguments to the function, which are X and Y offsets, like:
```{r}
grid_to_latlon("CE50", xoffset = 1, yoffset = 1)
```
for bottom right corner.

ATPOL 10km x 10km and 100km x 100k grids are generated by `atpol10k()` and `atpol100k()` functions respectively. It returns set of simple features geometries with grids as polygons:

```{r}
atpol100k()
```

For 10k grid it returns a centroids as well:
```{r}
atpol10k()
```

Please note, that ATPOL grids are projected in EPSG:2180 coordinate reference system, commonly used in Poland. 

Function `atpol_div(grid, divider)` divides any given `grid` to smaller grids by 2, 4 or 5 as proposed in [@vereyStandaryzacjaZapisuPodzialow2018].

```{r fig:atpol_div, echo = FALSE, message=FALSE, warning=FALSE, results='hide', fig.width = 7, fig.align='center', fig.cap="Division by 2, 4 and 5 with adopted naming convection d, c, p"}
par(mar = c(0, 0, 0, 0))
par(mfrow = c(1, 3))
for (d in c(2, 4, 5)) {
  a <- atpol_div("BE23", d)
  a$centroid <- sf::st_centroid(a$geometry)

  plot(a$geometry)
  a |>
    sf::st_set_geometry("centroid") |>
    subset(select = c("Name", "centroid")) |>
    terra::vect() |>
    terra::text(labels = substr(a$Name,5,7))
  
}
par(mfrow = c(1, 1))
```


```{r fig:boundaryPL, fig.width=6, fig.align='center', fig.cap="Boundary of Poland on ATPOL grid."}
par(mar = c(0, 0, 0, 0))
b <- boundaryPL()
plot(atpol100k()$geometry)
plot(b, col = "red", add = TRUE)
```

# Bibliography
